
\section{Constraint Based Type Inference}
\lable{sec:typeinfer}

The type inference currently used by OCaml has the algorithm $\mathcal W$ by
\citet{milner78} at its core.
Although it is very efficient and broadly extended to OCaml's 
requirements, it lacks sort of a memory:  For example, infering the type of a
variable is done by accumulating (unifying) information on its usages while
traversing the abstract syntax tree (AST).
Broadly spoken, a type constructor clash is detected as the usage just
inspected contradicts the information collected so far.
Therefore, OCaml's type checker cannot report any \emph{reasons} for a type
error but reports only the location where the error became obvious to the type
checker.
Much work while debugging type errors in OCaml comprises of manually searching
for other usages of the mis-typed variable in the program which might have lead
to the type constructor clash.


\subsection{Haack \& Wells}
\label{hd002001}
\citet{haackwells04} describe an algorithm which exceeds the algorithm
$\mathcal W$ in two ways:
Firstly, every type error report contains information on exactly those
locations in the program which are essential to the error, by means of dropping
it would vanish the error.
Secondly, it is able to report all type errors in a program at once (whilst
locations which are involved in several type errors are most notable the source
of the errors, by the way).

In a sense, algorithm $\mathcal W$ does two things at once while traversing the 
AST: it generates type information on the variables and unifies it with 
existing type information anon.  Haack \& Wells' algorithm works by separating
these steps.

During \emph{constraint generation} every node of the AST gets 
annotated with a type variable. While traversing the AST, information on 
these type variables is collected from the usage of each node.  This
information is stored as a set of constraints on the type variables.

The intention is the following: If they are \emph{unifiable} the resulting
substitution represents a valid typing of the program with respect to the type
variables of the nodes.

Otherwise, the program has at least one type error. But now, the 
collected type information is still available as a set of constraints 
and enables the algorithm to reexamine the errors in a second stage of 
\emph{error enumeration and minimization}: Error enumeration is 
basically done by systematically removing constraints grounded at one 
program location from the constraint set and running unification again.
\citet{haackwells04} also present an iterative version of this algorithm which
is implemented in EasyOCaml. Although it avoids recomputation of the same
errors over and over again, error enumeration has nevertheless exponential time
consumptions. Thus error enumeration delimited to a given time amount which can
be specified by the environment variable \texttt{EASYOCAML\_ENUM\_TIMEOUT}.

The result of error enumeration is a set of errors, each represented as a
complete set of locations whose nodes in the AST have to the error
(\emph{complete} in being a superset of the locations which caused the type
error). By application of error minimization on each error, the algorithm
further guarantees \emph{minimality} of the reported errors in the sense that
removing the constraints annotated with a location would vanish the error
itself.

In addition to type errors, \citeauthor{haackwells04}' technique also enables the 
type checker to collect unbound variables in the program while 
generating. Their types are assumed as a free variable to avoid a type 
error, but unbound variables are reported with the type errors after 
error enumeration.


\subsection{Extensions for \easyocaml}
\label{hd002002}
\citet{haackwells04} comes with constraint generation rules only for variables,
infix operations, functional abstraction, application and local polymorphic
variable bindings. This is a good starting point to describe the algorithms
involved, but we had to extend it to the \emph{Caml}$_{-m}$.

\new \easyocaml\ features a much richer type system, because it facilitates the
declaration of record types, variant types and type synonyms.

\dots

EasyOCaml features type annotations of the form \texttt{(t:ct)}. OCaml's
current type checker ignores the type annotations whilst unification by using
the term's inferred type and only checks its validity later on.
So type inference and error reporting makes no use of the type annotations
itself.
In contrast, EasyOCaml assumes terms to have the denoted type while type
checking, type checks the term isolated and tests the validity afterwards by
proving that the annotated type is a subtype of the inferred type.

\dots

\easyocaml\ facilitates references and mutable data.

\dots

\easyocaml\ collects as many errors as possible.

\begin{itemize}
    \item records \ldots{}
    \item variants \ldots{}
    \item type annotations \ldots{}
    \item references \ldots{}
\end{itemize}

See appendix~\ref{s:rules} for a complete list of inference rules used 
in EasyOCaml.
