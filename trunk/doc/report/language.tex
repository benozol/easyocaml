
\section{Supported Language}
\label{sec:language}

\easyocaml\ targets to be usable not only for the very first steps in
programming, so a reasonable subset of the \ocaml\ language is supported.
This language can be characterized as ``Caml without module declarations'',
hence its designation \camlm.

Unlike simpler functional programming languages like \textit{Scheme} with only a single
syntactic category \emph{expression}, \ocaml\ makes a distinction between 
\emph{structure items}, \emph{expressions} and \emph{patterns}.
Here is the supported language features in more detail, which also can be
pruned by teach packs. See section \ref{sec:grammar} for a complete grammar.


\subsection*{Structure items}

\ocaml\ programs consist of a list of \emph{structure items}, which are used to
declare values, types and exceptions.
\easyocaml\ supports
\begin{itemize}
  \item Optionally parametrized \emph{type declarations} of type synonyms,
    records with optionally mutable fields and variant types.
  \item \emph{exception declarations} like in \ocaml.
  \item optionally recursive (\texttt{rec}) and multiple (\texttt{and})
    \emph{value declarations}, where binding occur with arbitrary patterns.
    Note, that a languge level may require type annotations of those toplevel
    value declarations.
  \item Toplevel evaluations. Note that the toplevel evaluation of \texttt{e} is just
    syntactic sugar for \texttt{let \_ = e}.
\end{itemize}

\subsection*{Core types}
Direct combinations of existing types are called \emph{core types} in \ocaml.
\easyocaml\ allows as core types primitive types (\texttt{int}, \texttt{char},
\texttt{string} and \texttt{float}), free (in type annotations) and bound (in
type declarations) type variables, type arrows (function types), tuples and
type constructors, i.e.\ applications of parametrized types.

\subsection*{Expressions}

Expressions are parts of a program that can be evaluated to a \ocaml\ value and
occur only as part of structure items.
\easyocaml\ supports simple expressions that can be found in \textsl{MiniML},
too, like variables, functions, infix operators, conditionals and variable
binding.

Despite those, it features construction of tuples, records and variants,
conditionals with optional \texttt{else} branch, \texttt{while} and
\texttt{for} loops, sequences of expressions, exception handling (raising and
catching) as well as type annotations.

\subsection*{Patterns}

In \easyocaml, pattern matching is possible in every place where it works in
\ocaml, i.e.\ value matching\ttfootnote{match \ldots\ with \emph{pat} ->
\ldots\ | \ldots}, in variable bindings\ttfootnote{let \emph{pat} = \ldots}, in
functional abstractions with the \texttt{function} keyword\ttfootnote{function
\emph{pat} -> \ldots\ | \ldots} and exception catching\ttfootnote{try \ldots\
with \emph{pat} -> \ldots\ | \ldots}.

Pattern matching works for every possible value in \easyocaml, i.e.\ primitive
values, tuples, variants and records\footnote{version 0.49 lacks the
implementation for pattern matching on the latter} and every can be nested in
every level.

